[{"uri":"https://fslab.org/RProvider/reference/rprovider.html","title":"RProvider","content":"FSIPrinters \nHelpers \nOperators \nRDotNetExtensions \nRDotNetExtensions2 \nRInterop \nIConvertFromR\u003C\u0027TOutType\u003E \nIConvertToR\u003C\u0027TInType\u003E \nIDefaultConvertFromR \nREnv"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal.html","title":"RProvider.Internal","content":"Configuration \nLogging \nRInit"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-converters.html","title":"RProvider.Internal.Converters","content":"Factor"},{"uri":"https://fslab.org/RProvider/reference/rprovider-runtime.html","title":"RProvider.Runtime","content":"Serialisation"},{"uri":"https://fslab.org/RProvider/reference/rprovider-fsiprinters.html","title":"FSIPrinters","content":"FSIPrinters \n\n Print functions that may be used in\n F# interactive to \u0027pretty-print\u0027 R types to the\n console window. Use in your scripts by\n passing to \u0060fsi.AddPrinter\u0060.\n \nFSIPrinters.rValue \nrValue"},{"uri":"https://fslab.org/RProvider/reference/rprovider-fsiprinters.html#rValue","title":"FSIPrinters.rValue","content":"FSIPrinters.rValue \nrValue \n\n Print any \u0060SymbolicExpression\u0060 using R\u0027s built-in\n \u0060print\u0060 function.\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-helpers.html","title":"Helpers","content":"Helpers \n\n Contains helper functions for calling the functions generated by the R provider,\n such as the \u0060namedParams\u0060 function for specifying named parameters.\n The module is automatically opened when you open the \u0060RProvider\u0060 namespace.\n \nHelpers.namedParams \nnamedParams"},{"uri":"https://fslab.org/RProvider/reference/rprovider-helpers.html#namedParams","title":"Helpers.namedParams","content":"Helpers.namedParams \nnamedParams \n\n Construct a dictionary of named params to pass to an R function.\n\n ## Example\n For example, if you want to call the \u0060R.plot\u0060 function with named parameters\n specifying \u0060x\u0060, \u0060type\u0060, \u0060col\u0060 and \u0060ylim\u0060, you can use the following:\n\n     [ \u0022x\u0022, box widgets;\n       \u0022type\u0022, box \u0022o\u0022;\n       \u0022col\u0022, box \u0022blue\u0022;\n       \u0022ylim\u0022, box [0; 25] ]\n     |\u003E namedParams |\u003E R.plot\n\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-operators.html","title":"Operators","content":"Operators \n\n Custom operators that make composing and working with\n R symbolic expressions easier.\n \nOperators.( ? ) \n( ? ) \nOperators.( =\u003E ) \n( =\u003E )"},{"uri":"https://fslab.org/RProvider/reference/rprovider-operators.html#( ? )","title":"Operators.( ? )","content":"Operators.( ? ) \n( ? ) \n\n Opens a dynamic property of an R symbolic expression.\n Supports named lists, S4 objects, and dataframes.\n If a dataframe, the column is extracted by name.\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-operators.html#( =\u003E )","title":"Operators.( =\u003E )","content":"Operators.( =\u003E ) \n( =\u003E ) \n\n When calling an R function, use the =\u003E operator in a list\n to set a parameter: [ \u0022someparam\u0022 =\u003E 2 ]\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions.html","title":"RDotNetExtensions","content":"RDotNetExtensions \n\n [omit]\n \nRDotNetExtensions.SymbolicExpression \nSymbolicExpression \nRDotNetExtensions.Class \nClass \nRDotNetExtensions.Class \nClass \nRDotNetExtensions.GetValue \nGetValue \nRDotNetExtensions.Value \nValue \nRDotNetExtensions.Value \nValue \nRDotNetExtensions.Member \nMember \nRDotNetExtensions.ValueOf \nValueOf \nRDotNetExtensions.ValueAt \nValueAt \nRDotNetExtensions.First \nFirst \nRDotNetExtensions.TryFirst \nTryFirst"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions.html#Class","title":"RDotNetExtensions.Class","content":"RDotNetExtensions.Class \nClass \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions.html#Class","title":"RDotNetExtensions.Class","content":"RDotNetExtensions.Class \nClass \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions.html#GetValue","title":"RDotNetExtensions.GetValue","content":"RDotNetExtensions.GetValue \nGetValue \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions.html#Value","title":"RDotNetExtensions.Value","content":"RDotNetExtensions.Value \nValue \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions.html#Value","title":"RDotNetExtensions.Value","content":"RDotNetExtensions.Value \nValue \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions.html#Member","title":"RDotNetExtensions.Member","content":"RDotNetExtensions.Member \nMember \n\n Get the member symbolic expression of given name.\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions.html#ValueOf","title":"RDotNetExtensions.ValueOf","content":"RDotNetExtensions.ValueOf \nValueOf \n\n Get the value from the typed vector by name.\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions.html#ValueAt","title":"RDotNetExtensions.ValueAt","content":"RDotNetExtensions.ValueAt \nValueAt \n\n Get the value from an indexed vector by index.\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions.html#First","title":"RDotNetExtensions.First","content":"RDotNetExtensions.First \nFirst \n\n Get the first value of a vector.\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions.html#TryFirst","title":"RDotNetExtensions.TryFirst","content":"RDotNetExtensions.TryFirst \nTryFirst \n\n Try and get the first value of a vector, returning\n \u0060None\u0060 if the \u0060SymbolicExpression\u0060 is not a vector\n or an empty vector.\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions-symbolicexpression.html","title":"SymbolicExpression","content":"SymbolicExpression \n\n Contains functions to make working with SymbolicExpression\n more idiomatic.\n \nSymbolicExpression.trySlots \ntrySlots \nSymbolicExpression.slots \nslots \nSymbolicExpression.trySlot \ntrySlot \nSymbolicExpression.slot \nslot \nSymbolicExpression.column \ncolumn"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions-symbolicexpression.html#trySlots","title":"SymbolicExpression.trySlots","content":"SymbolicExpression.trySlots \ntrySlots \n For an S4 object, get a dictionary containing first the\n slot name and second the slot\u0027s R type. If the expression\n is not an S4 object, returns \u0060None\u0060."},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions-symbolicexpression.html#slots","title":"SymbolicExpression.slots","content":"SymbolicExpression.slots \nslots \n For an S4 object, get a dictionary containing first the\n slot name and second the slot\u0027s R type."},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions-symbolicexpression.html#trySlot","title":"SymbolicExpression.trySlot","content":"SymbolicExpression.trySlot \ntrySlot \nGets the value of a slot as a SymbolicExpression"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions-symbolicexpression.html#slot","title":"SymbolicExpression.slot","content":"SymbolicExpression.slot \nslot \nGets the value of a slot as a SymbolicExpression"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions-symbolicexpression.html#column","title":"SymbolicExpression.column","content":"SymbolicExpression.column \ncolumn \nGet the data from a column in an R dataframe\n by its name."},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions2.html","title":"RDotNetExtensions2","content":"RDotNetExtensions2 \n\n [omit]\n \nRDotNetExtensions2.Print \nPrint"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rdotnetextensions2.html#Print","title":"RDotNetExtensions2.Print","content":"RDotNetExtensions2.Print \nPrint \n\n Call the R print function and return output as a string\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rinterop.html","title":"RInterop","content":"RInterop \n\n [omit]\n \nRInterop.RValue \nRValue \nRInterop.serializeRValue \nserializeRValue \nRInterop.deserializeRValue \ndeserializeRValue \nRInterop.makeSafeName \nmakeSafeName \nRInterop.getPackages \ngetPackages \nRInterop.getPackageDescription \ngetPackageDescription \nRInterop.getFunctionDescriptions \ngetFunctionDescriptions \nRInterop.loadPackage \nloadPackage \nRInterop.getBindings \ngetBindings \nRInterop.callFunc \ncallFunc \nRInterop.call \ncall \nRInterop.toR \ntoR \nRInterop.defaultFromR \ndefaultFromR"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rinterop.html#serializeRValue","title":"RInterop.serializeRValue","content":"RInterop.serializeRValue \nserializeRValue \n\n Turn an \u0060RValue\u0060 (which captures type information of a value or function)\n into a serialized string that can be spliced in a quotation\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rinterop.html#deserializeRValue","title":"RInterop.deserializeRValue","content":"RInterop.deserializeRValue \ndeserializeRValue \n\n Given a string produced by \u0060serializeRValue\u0060, reconstruct the original RValue object\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rinterop.html#makeSafeName","title":"RInterop.makeSafeName","content":"RInterop.makeSafeName \nmakeSafeName \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rinterop.html#getPackages","title":"RInterop.getPackages","content":"RInterop.getPackages \ngetPackages \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rinterop.html#getPackageDescription","title":"RInterop.getPackageDescription","content":"RInterop.getPackageDescription \ngetPackageDescription \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rinterop.html#getFunctionDescriptions","title":"RInterop.getFunctionDescriptions","content":"RInterop.getFunctionDescriptions \ngetFunctionDescriptions \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rinterop.html#loadPackage","title":"RInterop.loadPackage","content":"RInterop.loadPackage \nloadPackage \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rinterop.html#getBindings","title":"RInterop.getBindings","content":"RInterop.getBindings \ngetBindings \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rinterop.html#callFunc","title":"RInterop.callFunc","content":"RInterop.callFunc \ncallFunc \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rinterop.html#call","title":"RInterop.call","content":"RInterop.call \ncall \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rinterop.html#toR","title":"RInterop.toR","content":"RInterop.toR \ntoR \n\n Convert a value to a value in R.\n Generally you shouldn\u0027t use this function - it is mainly for testing.\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rinterop.html#defaultFromR","title":"RInterop.defaultFromR","content":"RInterop.defaultFromR \ndefaultFromR \n\n Convert a symbolic expression to some default .NET representation\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rinterop-rvalue.html","title":"RValue","content":"RValue \n \nRValue.Function \nFunction \nRValue.Value \nValue"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rinterop-rvalue.html#Function","title":"RValue.Function","content":"RValue.Function \nFunction \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-rinterop-rvalue.html#Value","title":"RValue.Value","content":"RValue.Value \nValue \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-iconvertfromr-1.html","title":"IConvertFromR\u003C\u0027TOutType\u003E","content":"IConvertFromR\u003C\u0027TOutType\u003E \n\n This interface can be used for providing new convertors that can convert\n R values to .NET types. The converter is used whenever the users calls the\n \u0060se.GetValue\u003C\u0027TOutType\u003E()\u0060 on a \u0060SymbolicExpression\u0060 value returned from R\n provider.\n \nIConvertFromR\u003C\u0027TOutType\u003E.Convert \nConvert"},{"uri":"https://fslab.org/RProvider/reference/rprovider-iconvertfromr-1.html#Convert","title":"IConvertFromR\u003C\u0027TOutType\u003E.Convert","content":"IConvertFromR\u003C\u0027TOutType\u003E.Convert \nConvert \n\n The method is called when the user calls \u0060GetValue\u003C\u0027TOutType\u003E()\u0060 on a\n \u0060SymbolicExpression\u0060 value returned from the R provider.\n\n ## Example\n To use this interface, you need to write a plugin (\u0060YourPlugin.Plugin.dll\u0060)\n that exports an implementation of this interface using MEF. The method\n \u0060Convert\u0060 of the interface can return \u0060None\u0060 when the conversion is not\n possible.\n\n     [\u003CExport(typeof\u003CIConvertFromR\u003CMyType\u003E\u003E)\u003E]\n     type ConvertMyThingFromR() =\n       interface IConvertFromR\u003CMyThing\u003E with\n       member x.Convert(symExpr) =\n         Some(new MyThing()) // TODO: Convert \u0027symExpr\u0027 from R.\n\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-iconverttor-1.html","title":"IConvertToR\u003C\u0027TInType\u003E","content":"IConvertToR\u003C\u0027TInType\u003E \n\n This interface can be used for providing new convertors that can convert\n custom .NET data types to R values. The converter is used whenever the\n user calls an R function (such as \u0060R.foo(...)\u0060) with an arguments that\n is of type \u0060TInType\u0060.\n \nIConvertToR\u003C\u0027TInType\u003E.Convert \nConvert"},{"uri":"https://fslab.org/RProvider/reference/rprovider-iconverttor-1.html#Convert","title":"IConvertToR\u003C\u0027TInType\u003E.Convert","content":"IConvertToR\u003C\u0027TInType\u003E.Convert \nConvert \n\n The method is called when the user calls any of the provided R\n functions with a value of type \u0060\u0027TInType\u0060 as an argument.\n\n ## Example\n To use this interface, you need to write a plugin (\u0060YourPlugin.Plugin.dll\u0060)\n that exports an implementation of this interface using MEF. The method\n \u0060Convert\u0060 of the interface is called with the value of \u0060\u0027TInType\u0060 and should\n return an R symbolic expression.\n\n     [\u003CExport(typeof\u003CIConvertToR\u003CIFrame\u003E\u003E)\u003E]\n     type ConvertMyThingToR() =\n       interface IConvertToR\u003CIFrame\u003E with\n         member x.Convert(engine, input:MyThing) =\n           R.c(1,2,3) // TODO: Convert \u0027input\u0027 to R.\n\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-idefaultconvertfromr.html","title":"IDefaultConvertFromR","content":"IDefaultConvertFromR \n\n This interface can be used for providing a default converter that converts\n R value to .NET \u0060obj\u0060 values. The converter is used whenever the user calls the\n \u0060se.Value\u0060 member on \u0060SymbolicExpression. This property should convert an R\n value to the \u0022most appropriate\u0022 .NET object.\n \nIDefaultConvertFromR.Convert \nConvert"},{"uri":"https://fslab.org/RProvider/reference/rprovider-idefaultconvertfromr.html#Convert","title":"IDefaultConvertFromR.Convert","content":"IDefaultConvertFromR.Convert \nConvert \n\n The method is called when the user accesses the \u0060Value\u0060 property\n on a \u0060SymbolicExpression\u0060 value returned from the R provider.\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-renv.html","title":"REnv","content":"REnv \n\n The object represents an R environment loaded from RData file.\n This type is typically used through an \u0060RData\u0060 type provider. To\n get a statically typed R environment for a given file, use\n \u0060RData\u003C\u0022C:\\\\myfile.rdata\u0022\u003E\u0060.\n \nREnv.( .ctor ) \n( .ctor ) \nREnv.Get \nGet \nREnv.Keys \nKeys \nREnv.Environment \nEnvironment"},{"uri":"https://fslab.org/RProvider/reference/rprovider-renv.html#( .ctor )","title":"REnv.( .ctor )","content":"REnv.( .ctor ) \n( .ctor ) \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-renv.html#Get","title":"REnv.Get","content":"REnv.Get \nGet \n\n Get a value from the R environment as \u0060SymbolicExpression\u0060\n (This is equivalent to calling \u0060R.get\u0060 function)\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-renv.html#Keys","title":"REnv.Keys","content":"REnv.Keys \nKeys \n\n Returns the keys of all values available in the environment\n (This is equivalent to calling \u0060R.ls\u0060 function)\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-renv.html#Environment","title":"REnv.Environment","content":"REnv.Environment \nEnvironment \n\n Returns the underlying R environment, represented as \u0060SymbolicExpression\u0060\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-configuration.html","title":"Configuration","content":"Configuration \n\n [omit]\n \nConfiguration.getRProviderRuntimeAssembly \ngetRProviderRuntimeAssembly \nConfiguration.searchDirectories \nsearchDirectories \nConfiguration.getAssemblyLocation \ngetAssemblyLocation \nConfiguration.getConfigFileLocation \ngetConfigFileLocation \nConfiguration.probingLocationsFromXmlConfig \nprobingLocationsFromXmlConfig \nConfiguration.getProbingLocations \ngetProbingLocations \nConfiguration.resolveReferencedAssembly \nresolveReferencedAssembly \nConfiguration.isUnixOrMac \nisUnixOrMac \nConfiguration.getRProviderConfValue \ngetRProviderConfValue"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-configuration.html#getRProviderRuntimeAssembly","title":"Configuration.getRProviderRuntimeAssembly","content":"Configuration.getRProviderRuntimeAssembly \ngetRProviderRuntimeAssembly \n\n Returns the Assembly object of RProvider.Runtime.dll (this needs to\n work when called from RProvider.DesignTime.dll and also RProvider.Server.exe/dll)\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-configuration.html#searchDirectories","title":"Configuration.searchDirectories","content":"Configuration.searchDirectories \nsearchDirectories \n\n Finds directories relative to \u0027dirs\u0027 using the specified \u0027patterns\u0027.\n Patterns is a string, such as \u0022..\\foo\\*\\bar\u0022 split by \u0027\\\u0027. Standard\n .NET libraries do not support \u0022*\u0022, so we have to do it ourselves..\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-configuration.html#getAssemblyLocation","title":"Configuration.getAssemblyLocation","content":"Configuration.getAssemblyLocation \ngetAssemblyLocation \n\n Returns the real assembly location - when shadow copying is enabled, this\n returns the original assembly location (which may contain other files we need)\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-configuration.html#getConfigFileLocation","title":"Configuration.getConfigFileLocation","content":"Configuration.getConfigFileLocation \ngetConfigFileLocation \n\n Returns the real config file location even when shadow copying is enabled.\n To account for single-file server executables, we use AppContext.BaseDirectory\n and navigate up two directories to get to the original RProvider.Runtime.dll\n location where the config file is (from server/{platform}/)\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-configuration.html#probingLocationsFromXmlConfig","title":"Configuration.probingLocationsFromXmlConfig","content":"Configuration.probingLocationsFromXmlConfig \nprobingLocationsFromXmlConfig \n\n Load a .config XML file and obtain the value of the AppSetting\n called \u0027ProbingLocations\u0027.\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-configuration.html#getProbingLocations","title":"Configuration.getProbingLocations","content":"Configuration.getProbingLocations \ngetProbingLocations \n\n Reads the \u0027RProvider.dll.config\u0027 file and gets the \u0027ProbingLocations\u0027\n parameter from the configuration file. Resolves the directories and returns\n them as a list.\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-configuration.html#resolveReferencedAssembly","title":"Configuration.resolveReferencedAssembly","content":"Configuration.resolveReferencedAssembly \nresolveReferencedAssembly \n\n Given an assembly name, try to find it in either assemblies\n loaded in the current AppDomain, or in one of the specified\n probing directories.\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-configuration.html#isUnixOrMac","title":"Configuration.isUnixOrMac","content":"Configuration.isUnixOrMac \nisUnixOrMac \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-configuration.html#getRProviderConfValue","title":"Configuration.getRProviderConfValue","content":"Configuration.getRProviderConfValue \ngetRProviderConfValue \n\n On Mac (and Linux), we use ~/.rprovider.conf in user\u0027s home folder for\n various configuration (64-bit mono and R location if we cannot determine it)\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-logging.html","title":"Logging","content":"Logging \n\n [omit]\n \nLogging.logf \nlogf"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-logging.html#logf","title":"Logging.logf","content":"Logging.logf \nlogf \n\n Log formatted string to a log file\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-rinit.html","title":"RInit","content":"RInit \n\n [omit]\n \nRInit.RInitResult\u003C\u0027T\u003E \nRInitResult\u003C\u0027T\u003E \nRInit.RLocation \nRLocation \nRInit.setRHomeEnvironmentVariable \nsetRHomeEnvironmentVariable \nRInit.rHomePath \nrHomePath"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-rinit.html#setRHomeEnvironmentVariable","title":"RInit.setRHomeEnvironmentVariable","content":"RInit.setRHomeEnvironmentVariable \nsetRHomeEnvironmentVariable \n\n Sets the R_HOME environmental variable if it is not already set\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-rinit.html#rHomePath","title":"RInit.rHomePath","content":"RInit.rHomePath \nrHomePath \n\n Lazily initialized value that, find the R location or fails and returns RInitError\n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-rinit-rinitresult-1.html","title":"RInitResult\u003C\u0027T\u003E","content":"RInitResult\u003C\u0027T\u003E \n\n Represents R value used in initialization or information about failure\n \nRInitResult\u003C\u0027T\u003E.RInitResult \nRInitResult \nRInitResult\u003C\u0027T\u003E.RInitError \nRInitError"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-rinit-rinitresult-1.html#RInitResult","title":"RInitResult\u003C\u0027T\u003E.RInitResult","content":"RInitResult\u003C\u0027T\u003E.RInitResult \nRInitResult \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-rinit-rinitresult-1.html#RInitError","title":"RInitResult\u003C\u0027T\u003E.RInitError","content":"RInitResult\u003C\u0027T\u003E.RInitError \nRInitError \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-rinit-rlocation.html","title":"RLocation","content":"RLocation \n \nRLocation.DllFile \nDllFile \nRLocation.RPath \nRPath \nRLocation.RHome \nRHome"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-rinit-rlocation.html#DllFile","title":"RLocation.DllFile","content":"RLocation.DllFile \nDllFile \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-rinit-rlocation.html#RPath","title":"RLocation.RPath","content":"RLocation.RPath \nRPath \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-rinit-rlocation.html#RHome","title":"RLocation.RHome","content":"RLocation.RHome \nRHome \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-converters-factor.html","title":"Factor","content":"Factor \n\n Contains higher-level converters\n [omit]\n \nFactor.DataFrameConverter \nDataFrameConverter \nFactor.FactorVectorConverter \nFactorVectorConverter \nFactor.getLevels \ngetLevels \nFactor.tryConvert \ntryConvert"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-converters-factor.html#getLevels","title":"Factor.getLevels","content":"Factor.getLevels \ngetLevels \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-converters-factor.html#tryConvert","title":"Factor.tryConvert","content":"Factor.tryConvert \ntryConvert \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-converters-factor-dataframeconverter.html","title":"DataFrameConverter","content":"DataFrameConverter \n \nDataFrameConverter.( .ctor ) \n( .ctor )"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-converters-factor-dataframeconverter.html#( .ctor )","title":"DataFrameConverter.( .ctor )","content":"DataFrameConverter.( .ctor ) \n( .ctor ) \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-converters-factor-factorvectorconverter.html","title":"FactorVectorConverter","content":"FactorVectorConverter \n \nFactorVectorConverter.( .ctor ) \n( .ctor )"},{"uri":"https://fslab.org/RProvider/reference/rprovider-internal-converters-factor-factorvectorconverter.html#( .ctor )","title":"FactorVectorConverter.( .ctor )","content":"FactorVectorConverter.( .ctor ) \n( .ctor ) \n"},{"uri":"https://fslab.org/RProvider/reference/rprovider-runtime-serialisation.html","title":"Serialisation","content":"Serialisation \n\n [omit]\n \nSerialisation.NewtonsoftJsonPipeSerializer \nNewtonsoftJsonPipeSerializer"},{"uri":"https://fslab.org/RProvider/reference/rprovider-runtime-serialisation-newtonsoftjsonpipeserializer.html","title":"NewtonsoftJsonPipeSerializer","content":"NewtonsoftJsonPipeSerializer \n\n We are using Newtonsoft rather than System.Text.Json because\n the latter does not support System.Type.\n \nNewtonsoftJsonPipeSerializer.( .ctor ) \n( .ctor )"},{"uri":"https://fslab.org/RProvider/reference/rprovider-runtime-serialisation-newtonsoftjsonpipeserializer.html#( .ctor )","title":"NewtonsoftJsonPipeSerializer.( .ctor )","content":"NewtonsoftJsonPipeSerializer.( .ctor ) \n( .ctor ) \n"},{"uri":"https://fslab.org/RProvider/devnotes.html","title":"Developer notes\n","content":"---\ncategory: Developer\ncategoryindex: 2\nindex: 3\n---\n\nDeveloper notes\n===============\n\nThere are two things that make the R type provider tricky:\n\n * When you use R provider via NuGet and the F# compiler references the \n   R provider, it attempts to load it from the location where NuGet puts\n   it. This is typically \u0060packages/RProvider.1.0.8/lib\u0060. This directory\n   does *not* contain \u0060RDotNet.dll\u0060 (which is installed in \u0060packages/R.NET.1.3.5/lib/net40\u0060)\n   and so the loading could fail.\n\n   To avoid this, we need to make sure that the assembly that is loaded by\n   the F# compiler (and Visual Studio) does not trigger loading of R.NET\n   immediately - that way, we can setup \u0060AssemblyResolve\u0060 event handler\n   and load R.NET assembly from another directory.\n   \n * Connecting to R is not entirely stable and so we do not want to crash the\n   F# compiler (or Visual Studio) when something goes wrong with R. For this \n   reason, we run the type discovery in a separate process and communicate\n   with it via .NET remoting.\n\nProject structure\n-----------------\n\nTo solve the two issues outlined above, the project structure looks like this:\n\n\u003Cdiv style=\u0022margin:40px\u0022\u003E\n\u003Cimg src=\u0022misc/diagram.png\u0022 /\u003E\n\u003C/div\u003E\n\nThings to keep in mind\n----------------------\n\nHere is what you need to know about individual assemblies in the solution:\n\n * \u0060RProvider.Runtime.dll\u0060 - this is the assembly that contains most of the \n   interesting runtime functionality (such as initialization of R, interop\n   with R and converters that convert values between F# and R). It also contains\n   helpers (logging, etc.). \n   \n   This assembly references R.NET in its public assemblies and so when it\n   is loaded, .NET needs to be able to load R.NET (i.e. the \u0060AssemblyResolve\u0060\n   event handler needs to be set up).\n\n * \u0060RProvider.dll\u0060 - this is the assembly that the user of R provider will \n   reference. It does not contain any useful code - it only contains \n   \u0060TypeProviderAssembly\u0060 attribute pointing to the assembly with the actual\n   type provider code. \n   \n   Note that we cannot put the functionality from \u0060RProvider.Runtime.dll\u0060 \n   here, because the code needs to be referenced by the other two assemblies\n   (that are compiled before the type provider can be loaded).\n\n * \u0060RProvider.DesignTime.dll\u0060 - this is where the type provider code lives.\n   This sets up \u0060AssemblyResolve\u0060 event handler and then it generates types\n   (by calling the \u0060RProvider.Server.exe\u0060 to do the type discovery).\n\n * \u0060RProvider.Server.exe\u0060 - this is started as a stand-alone process that \n   performs type and package discovery in R. It is called by the DesignTime\n   component and restarted automatically. This also needs to setup the \n   \u0060AssemblyResolve\u0060 event handler."},{"uri":"https://fslab.org/RProvider/reading-rdata.html","title":"Reading and writing RData files\n","content":"(**\n---\ncategory: Documentation\ncategoryindex: 1\nindex: 5\n---\n*)\n\n(*** condition: prepare ***)\n#nowarn \u0022211\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.Runtime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.DesignTime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.dll\u0022\n(*** condition: fsx ***)\n#if FSX\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // IPYNB\n\n(**\nReading and writing RData files\n===============================\n\nWhen using R, you can save and load data sets as \u0060*.rdata\u0060 files. These can be easily\nexported and consumed using the R provider too, so if you want to perform part of your\ndata acquisition, analysis and visualization using F# and another part using R, you \ncan easily pass the data between F# and R as \u0060*.rdata\u0060 files.\n\nPassing data from R to F#\n-------------------------\n\nLet\u0027s say that you have some data in R and want to pass them to F#. To do that, you\ncan use the \u0060save\u0060 function in R. The following R snippet creates a simple \u0060*.rdata\u0060\nfile containing a couple of symbols from the sample \u0060volcano\u0060 data set:\n\n    [lang=text]\n    require(datasets)\n    volcanoList \u003C- unlist(as.list(volcano))\n    volcanoMean \u003C- mean(volcanoList)\n    symbols \u003C- c(\u0022volcano\u0022, \u0022volcanoList\u0022, \u0022volcanoMean\u0022)\n    save(list=symols, file=\u0022C:/data/sample.rdata\u0022)\n\nTo import the data on the F# side, you can use the \u0060RData\u0060 type provider that is\navailable in the \u0060RProvider\u0060 namespace. It takes a static parameter specifying the\npath of the file (absolute or relative) and generates a type that exposes all the\nsaved values as static members:\n*)\nopen RProvider\n\ntype Sample = RData\u003C\u0022data/sample.rdata\u0022\u003E\nlet sample = Sample()\n\n// Easily access saved values\nsample.volcano\nsample.volcanoList\nsample.volcanoMean\n\n(**\nWhen accessed, the type provider automatically converts the data from the R format\nto F# format. In the above example, \u0060volcanoList\u0060 is imported as \u0060float[]\u0060 and\nthe \u0060volcanoMean\u0060 value is a singleton array. (The provider does not detect that \nthis is a singleton, so you can get the value using \u0060sample.volcanoMean.[0]\u0060).\nFor the \u0060sample.volcano\u0060 value, the R provider does not have a default conversion\nand so it is exposed as \u0060SymbolicExpression\u0060. \n\nWhen you have a number of \u0060*.rdata\u0060 files containing data in the same format, you can\npick one of them as a sample (which will be used to determine the fields of the type)\nand then pass the file name to the constructor of the generated type to load it.\nFor example, if we had files \u0060data/sample_1.rdata\u0060 to \u0060data/sample_10.rdata\u0060, we could\nread them as:\n*)\nlet means = \n  [ for i in 1 .. 10 -\u003E\n      let data = Sample(sprintf \u0022data/sample_%d.rdata\u0022 i)\n      data.volcanoMean.[0] ]\n(**\nNote that the default conversions available depend on the plugins that are currently\navailable. For example, when you install the enrie [FsLab](http://www.fslab.org) package\nwith the [Deedle](https://fslab.org/Deedle/) library, the \u0060RData\u0060 \nprovider will automatically expose data frames as Deedle \u0060Frame\u003Cstring, string\u003E\u0060 values.\n\nPassing data from F# to R\n-------------------------\n\nIf you perform data acquisition in F# and then want to pass the data to R, you \ncan use the standard R functions for saving the \u0060*.rdata\u0060 files. The easiest \noption is to call the \u0060R.assign\u0060 function to define named values in the R environment\nand then use \u0060R.save\u0060 to save the environment to a file:\n*)\n// Calculate sum of square differences\nlet avg = sample.volcanoList |\u003E Array.average\nlet sqrs = \n  sample.volcanoList \n  |\u003E Array.map (fun v -\u003E pown (v - avg) 2)\n\n// Save the squares to an RData file\nR.assign(\u0022volcanoDiffs\u0022, sqrs)\nR.save(list=[ \u0022volcanoDiffs\u0022 ], file=\u0022C:/temp/volcano.rdata\u0022)\n(**\nIt is recommended to use the \u0060list\u0060 parameter of the \u0060save\u0060 function to specify the\nnames of the symbols that should be saved, rather than saving *all* symbols. The R\nprovider uses additional temporary symbols and so the saved file would otherwise contain\nunnecessary fileds.\n\nOnce you save the file using the above command, you can re-load it again using\nthe \u0060RData\u0060 type provider, such as: \u0060new RData\u003C\u0022C:/temp/volcano.rdata\u0022\u003E()\u0060.\n*)"},{"uri":"https://fslab.org/RProvider/howto.html","title":"How to\n","content":"---\ncategory: Documentation\ncategoryindex: 1\nindex: 3\n---\n\n# How to\n\n## Printing R values to the console (F# interactive)\n\nAdd this line to your script to tell F# interactive how to print out\nthe values of R objects:\n\n    [lang=fsharp]\n    fsi.AddPrinter FSIPrinters.rValue\n\n## Packages\n\n### How do I Load a Package?\n\nRProvider discovers the packages installed in your R installation and makes them available as packages under the RProvider root namespace.  The actual package is lazily loaded the first time you access it.  \n\n### How do I install a new Package?\n\nCurrently you need to load up a real R session, then install the package via install.packages, or the Packages/Install Packages... menu.  You will then need to restart Visual Studio because the set of installed packages is cached inside the RProvider.\n\n#### I have a package installed and it is not showing up\nThe most likely cause is that RProvider is using a different R installation from the one you updated.  When you install R, you get the option to update the registry key \u0060HKEY_LOCAL_MACHINE\\SOFTWARE\\R-core\u0060 to point to the version you are installing.  This is what RProvider uses.  If you are running in a 32-bit process, RProvider uses \u0060HKEY_LOCAL_MACHINE\\SOFTWARE\\R-core\\R\\InstallPath\u0060 to determine the path.  For 64-bit, it reads \u0060HKEY_LOCAL_MACHINE\\SOFTWARE\\R-core\\R64\\InstallPath\u0060.  When you install a package in a given version of R, it should be available in both the 32-bit and 64-bit versions.\n\n## Function and Package names\nThere are a couple of mismatches between allowed identifiers between R and F#:\n### Dots in names\nIt is pretty common in R to use a dot character in a name, because the character has no special meaning.  We remap dots to underscore, and underscore to a double-underscore.  So for example, data.frame() becomes R.data_frame().\n\n### Names that are reserved F# keywords\nSome package and function names are reserved words in F#.  For these, you will need to quote them using double-backquotes.  Typically, the IDE will do this for you.  A good example is the base package, which will require an open statement where \u0022base\u0022 is double-back-quoted.\n"},{"uri":"https://fslab.org/RProvider/passing-data.html","title":"Passing Data Between F# and R\n","content":"(**\n---\ncategory: Documentation\ncategoryindex: 1\nindex: 3\n---\n*)\n\n(*** condition: prepare ***)\n#nowarn \u0022211\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.FSharp.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.Runtime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.DesignTime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.dll\u0022\n(*** condition: fsx ***)\n#if FSX\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // IPYNB\n\n\nopen RDotNet\nopen RProvider\n\n(**\n# Passing Data Between F# and R\n\n## Passing Parameters\n\n### Parameter Passing Conventions\n\nR supports various kinds of parameters, which we try to map onto equivalent F# parameter types:\n\n * All R formal parameters have names, and you can always pass their values either by name or positionally.  If you pass by name, you can skip arguments in your actual argument list.  We simply map these onto F# arguments, which you can also pass by name or positionally.\n\n * In R, essentially all arguments are optional (even if no default value is specified in the function argument list).  It\u0027s up to the receiving function to determine whether to error if the value is missing.   So we make all arguments optional.\n\n * R functions support ... (varargs/paramarray).  We map this onto a .NET ParamArray, which allows an arbitrary number of arguments to be passed.  However, there are a couple of kinks with this:\n\n    * R allows named arguments to appear _after_ the ... argument, whereas .NET requires the ParamArray argument to be at the end.  Some R functions use this convention because their primary arguments are passed in the ... argument and the named arguments will sometimes be used to modify the behavior of the function.  From the RProvider you will to supply values for the positional arguments before you can pass to the ... argument.  If you don\u0027t want to supply a value to one of these arguments, you can explicitly pass System.Reflection.Missing.\n\n    * Parameters passed to the R ... argument can also be passed using a name.  Those names are accessible to the calling function.  Example are list and dataframe construction (R.list, and R.data_frame).  To pass arguments this way, you can use the overload of each function that takes an IDictionary\u003Cstring, obj\u003E, either directly, or using the namedParams function.  For example:\n\n        R.data_frame(namedParams [ \u0022A\u0022, [|1;2;3|]; \u0022B\u0022, [|4;5;6|] ])\n\n### Parameter Types\n\nSince all arguments to functions are of type obj, it is not necessarily obvious what you can pass.  Ultimately, you will need to know what the underlying function is expecting, but here is a table to help you.  When reading this, remember that for most types, R supports only vector types.  There are no scalar string, int, bool etc. types.\n\n\u003Ctable class=\u0022table table-bordered table-striped\u0022\u003E\n\u003Ctr\u003E\u003Cth\u003ER Type\u003C/th\u003E\u003Cth\u003EF#/.NET Type\u003C/th\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Echaracter\u003C/td\u003E\u003Ctd\u003Estring or string[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Ecomplex\u003C/td\u003E\u003Ctd\u003ESystem.Numerics.Complex or Complex[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Einteger\u003C/td\u003E\u003Ctd\u003Eint or int[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Elogical\u003C/td\u003E\u003Ctd\u003Ebool or bool[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Enumeric\u003C/td\u003E\u003Ctd\u003Edouble or double[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Elist\u003C/td\u003E\u003Ctd\u003ECall R.list, passing the values as separate arguments\u003C/td\u003E\u003Ctr\u003E\n\u003Ctr\u003E\u003Ctd\u003Edataframe\u003C/td\u003E\u003Ctd\u003ECall R.data_frame, passing column vectors in a dictionary\u003C/td\u003E\u003Ctr\u003E\n\u003C/table\u003E\n\n**NB**: For any input, you can also pass a SymbolicExpression instance you received as the result of calling another R function.  Doing so it a very efficient way of passing data from one function to the next, since there is no marshalling between .NET and R types in that case.\n\n### Creating and passing an R function\nR has some high-level functions (e.g. sapply) that require a function parameter. Although F# has first-class support of functional programming and provides better functionality and syntax for apply-like operations, which often makes it sub-optimal to call apply-like high-level functions in R, the need for parallel computing in R, which is not yet directly supported by F# parallelism to R functions, requires users to pass a function as parameter. Here is an example way to create and pass an R function:\n*)\nlet fun1 = R.eval(R.parse(text=\u0022function(i) {mean(rnorm(i))}\u0022))\nlet nums = R.sapply(R.c(1,2,3),fun1)\n(**\nThe same usage also applies to parallel apply functions in parallel package.\n\n## Accessing results\n\nFunctions exposed by the RProvider return an instance of \u0060RDotNet.SymbolicExpression\u0060.  This keeps all return data inside R data structures, so does not impose any data marshalling overhead.  If you want to pass the value in as an argument to another R function, you can simply do so.\n\nIn order to access the result in .NET code, you have three routes:\n\n### Convert the data into a specified .NET type via GetValue\u003Ctype\u003E()\n\nRProvider adds a generic \u0060GetValue\u003C\u0027T\u003E\u0060 extension method to \u0060SymbolicExpression\u0060.  This supports conversions from certain R values to specific .NET types.  Here are the currently supported conversions:\n\n\u003Ctable class=\u0022table table-bordered table-striped\u0022\u003E\n\u003Ctr\u003E\u003Cth\u003ER Type\u003C/th\u003E\u003Cth\u003ERequested F#/.NET Type\u003C/th\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Echaracter (when vector is length 1)\u003C/td\u003E\u003Ctd\u003Estring\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Echaracter\u003C/td\u003E\u003Ctd\u003Estring[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Ecomplex (when vector is length 1)\u003C/td\u003E\u003Ctd\u003EComplex\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Ecomplex\u003C/td\u003E\u003Ctd\u003EComplex[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Einteger (when vector is length 1)\u003C/td\u003E\u003Ctd\u003Eint\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Einteger\u003C/td\u003E\u003Ctd\u003Eint[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Elogical (when vector is length 1)\u003C/td\u003E\u003Ctd\u003Ebool\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Elogical\u003C/td\u003E\u003Ctd\u003Ebool[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Enumeric (when vector is length 1)\u003C/td\u003E\u003Ctd\u003Edouble\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Enumeric\u003C/td\u003E\u003Ctd\u003Edouble[]\u003C/td\u003E\u003C/tr\u003E\n\u003C/table\u003E\n\nCustom conversions can be supported through [plugins](plugins.html).\n\n### Convert the data into the default .NET type the .Value property\n\nWe also expose an extension property called Value that performs a _default_ conversion of a SymbolicExpresion to a .NET type.  These are the current conversions:\n\n\u003Ctable class=\u0022table table-bordered table-striped\u0022\u003E\n\u003Ctr\u003E\u003Cth\u003ER Type\u003C/th\u003E\u003Cth\u003EF#/.NET Type\u003C/th\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Echaracter\u003C/td\u003E\u003Ctd\u003Estring[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Ecomplex\u003C/td\u003E\u003Ctd\u003EComplex[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Einteger\u003C/td\u003E\u003Ctd\u003Eint[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Elogical\u003C/td\u003E\u003Ctd\u003Ebool[]\u003C/td\u003E\u003C/tr\u003E\n\u003Ctr\u003E\u003Ctd\u003Enumeric\u003C/td\u003E\u003Ctd\u003Edouble[]\u003C/td\u003E\u003C/tr\u003E\n\u003C/table\u003E\n\nAgain, custom conversions can be supported through [plugins](plugins.html).\n\n### Explicitly access the data in the SymbolicExpression\n\nIf there are no supported conversions, you can access the data through the RDotNet object model.  RDotNet exposes properties, members and extension members (available only if you open the RDotNet namespace) that allow you to access the underlying data directly.  So, for example:\n*)\n\nlet res = R.sum([|1;2;3;4|])\nif res.Type = RDotNet.Internals.SymbolicExpressionType.IntegerVector then res.AsInteger().[0]\nelse failwithf \u0022Expecting a Numeric but got a %A\u0022 res.Type\n\n(**\nTo make this easier, we have defined some active patterns, under the RProvider.Helpers namespace, which is auto-opened when you open the RProvider namespace.  These combine the type tests and conversion.  An equivalent example:\n*)\n\nmatch R.sum([|1;2;3;4|]) with \n| IntegerVector(iv) -\u003E iv.[0]\n| _                 -\u003E failwithf \u0022Expecting a Numeric but got a %A\u0022 res.Type\n\n(**\n## What if I commonly need an argument or result conversion that RProvider does not support?\n\nIf you believe the argument conversion is universally appropriate and should be available to everybody, please fork the repo and submit a pull request.\n\nRProvider also supports custom conversions to/from your own data types using [plugins](plugins.html).\n*)"},{"uri":"https://fslab.org/RProvider/quickstart-statistics.html","title":"Quickstart: Using Statistical Packages\n","content":"(**\n---\ncategory: Documentation\ncategoryindex: 1\nindex: 3\n---\n*)\n\n(*** condition: prepare ***)\n#nowarn \u0022211\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/DynamicInterop.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.Runtime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.DesignTime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.dll\u0022\n#r \u0022RProvider.dll\u0022\n#r \u0022RProvider.DesignTime.dll\u0022\n(*** condition: fsx ***)\n#if FSX\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // IPYNB\n\n(** \n# Quickstart: Using Statistical Packages\n\nR is a programming language designed for statistics and data mining.\nThe R community is strong, and created an incredibly rich open source\necosystem of packages. \n\nThe F# R Type Provider enables you to use every single one of them,\nfrom within the F# environment. You can manipulate data using F#,\nsend it to R for computation, and extract back the results.\n\n## Example: Linear Regression\n\nLet\u0027s perform a simple linear regression from the F# interactive, \nusing the R.lm function.\n\nAssuming you installed the R Type Provider in your project from NuGet, \nyou can reference the required libraries and packages this way:\n*)\n\n#I \u0022../packages/RProvider.1.0.11\u0022\n#load \u0022RProvider.fsx\u0022\n\nopen RDotNet\nopen RProvider\nopen RProvider.Operators\n\nopen RProvider.graphics\nopen RProvider.stats\n\n(**\nOnce the libraries and packages have been loaded, \nImagine that our true model is\n\nY = 5.0 \u002B 3.0 * X1 - 2.0 * X2 \u002B noise\n\nLet\u0027s generate a fake dataset that follows this model:\n*)\n\n// Random number generator\nlet rng = System.Random()\nlet rand () = rng.NextDouble()\n\n// Generate fake X1 and X2 \nlet X1s = [ for i in 0 .. 9 -\u003E 10. * rand () ]\nlet X2s = [ for i in 0 .. 9 -\u003E 5. * rand () ]\n\n// Build Ys, following the \u0022true\u0022 model\nlet Ys = [ for i in 0 .. 9 -\u003E 5. \u002B 3. * X1s.[i] - 2. * X2s.[i] \u002B rand () ]\n\n(**\nUsing linear regression on this dataset, we should be able to \nestimate the coefficients 5.0, 3.0 and -2.0, with some imprecision\ndue to the \u0022noise\u0022 part.\n\nLet\u0027s first put our dataset into a R dataframe; this allows us\nto name our vectors, and use these names in R formulas afterwards:\n*)\n\nlet dataset = [ \n    \u0022Y\u0022 =\u003E Ys\n    \u0022X1\u0022 =\u003E X1s\n    \u0022X2\u0022 =\u003E X2s ] |\u003E R.data_frame\n\n(**\nWe can now use R to perform a linear regression.\nWe call the [R.lm function](http://stat.ethz.ch/R-manual/R-patched/library/stats/html/lm.html),\npassing it the formula we want to estimate. \n(See the [R manual on formulas](http://stat.ethz.ch/R-manual/R-patched/library/stats/html/formula.html) \nfor more on their somewhat esoteric construction) \n*)\n\nlet result = R.lm(formula = \u0022Y~X1\u002BX2\u0022, data = dataset)\n\n(**\n## Extracting Results from R to F#\n\nThe result we get back from R is a R Expression. \nThe R Type Provider tries as much as possible to keep data\nas R Expressions, rather than converting back-and-forth\nbetween F# and R types. It limits translations \nbetween the 2 languages, which has performance benefits, \nand simplifies composing R operations. On the other hand, \nwe need to extract the results from the R expression \ninto F# types.\n\nThe [R docs for lm](http://stat.ethz.ch/R-manual/R-patched/library/stats/html/lm.html) \ndescribes what R.lm returns: a R List. We can now retrieve each element, \naccessing it by name (as defined in the documentation). \nFor instance, let\u0027s retrieve the coefficients and residuals, \nwhich are both R vectors containg floats:\n*)\n\nlet coefficients = result.AsList().[\u0022coefficients\u0022].AsNumeric()\nlet residuals = result.AsList().[\u0022residuals\u0022].AsNumeric()\n\n(**\nWe can also produce summary statistics about our model,\nlike R^2, which measures goodness-of-fit - close to 0\nindicates a very poor fit, and close to 1 a good fit.\nSee [R docs for the details on Summary](http://stat.ethz.ch/R-manual/R-patched/library/stats/html/summary.lm.html).\n*)\n\nlet summary = R.summary(result)\nsummary.AsList().[\u0022r.squared\u0022].AsNumeric()\n\n(**\nFinally, we can directly pass results, which is a R expression,\nto R.plot, to produce some fancy charts describing our model:\n*)\n\n(***do-not-eval***)\nR.plot result\n\n(**\nThat\u0027s it - while simple, we hope this example illustrate\nhow you would go about to use any existing R statistical package. \nWhile the details would differ, the general approach would\nremain the same. Happy modelling!\n*)"},{"uri":"https://fslab.org/RProvider/tutorial.html","title":"R Provider Tutorial\n","content":"(**\n---\ncategory: Documentation\ncategoryindex: 1\nindex: 1\n---\n*)\n\n(*** condition: prepare ***)\n#nowarn \u0022211\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.Runtime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.DesignTime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.dll\u0022\n(*** condition: fsx ***)\n#if FSX\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // IPYNB\n\n(** \n# R Provider Tutorial\n\nThis tutorial demonstrates how to use the R type provider in an F# script. You\ncan also use the R type provider in other scenarios such as apps and libraries.\n\n## System requirements\n\nMake sure you have set up your system as specified [here](requirements.fsx).\n\n## Referencing the provider\n\nFirst, make a new F# script (e.g., sample.fsx). In your new script, first load\nthe R type provider from the NuGet package repository.\n\n    [lang=fsharp]\n    #r \u0022nuget:RProvider\u0022\n\nFor this tutorial, we use \u0060open\u0060 to reference a number of packages \nincluding \u0060stats\u0060, \u0060tseries\u0060 and \u0060zoo\u0060:\n*)\n \nopen RProvider\nopen RProvider.graphics\nopen RProvider.stats\nopen RProvider.tseries\nopen RProvider.zoo\n\nopen System\nopen System.Net.Http\n(**\nIf either of the namespaces above are unrecognized, you need to install the package in R\nusing \u0060install.packages(\u0022stats\u0022)\u0060.\n\n## Pretty-printing R values\n\nAdd this line to your script to tell F# interactive how to print out\nthe values of R objects:\n*)\n\nfsi.AddPrinter FSIPrinters.rValue\n\n(**\n## Obtaining data\n\nIn this tutorial, we use [F# Data](http://fsharp.github.io/FSharp.Data/) to access stock\nprices from the Yahoo Finance portal. For more information, see the documentation for the\n[CSV type provider](http://fsharp.github.io/FSharp.Data/library/CsvProvider.html).\n\nThe following snippet defines a function \u0060getStockPrices\u0060 that returns\narray with prices for the specified stock and a specified number of days from a stocks API:\n*)\n\n// NB The \u0027demo\u0027 key has very limited usage.\nlet apiKey = \u0022demo\u0022\n\n// URL of a service that generates price data\nlet url stock = sprintf \u0022https://www.alphavantage.co/query?function=TIME_SERIES_DAILY\u0026symbol=%s\u0026apikey=%s\u0026datatype=csv\u0022 stock apiKey\n\n/// Returns prices (as tuple) of a given stock\nlet getStockPrices stock count =\n    // Download the data and split it into lines\n    use wc = new HttpClient()\n    let data = wc.GetStringAsync(url stock) |\u003E Async.AwaitTask |\u003E Async.RunSynchronously\n    let dataLines = data.Split([| \u0027\\n\u0027 |], StringSplitOptions.RemoveEmptyEntries)\n \n    // Parse lines of the CSV file and take specified\n    // number of days using in the oldest to newest order\n    seq { for line in dataLines |\u003E Seq.skip 1 do\n              let infos = line.Split(\u0027,\u0027)\n              yield float infos.[4] }\n    |\u003E Seq.truncate count |\u003E Array.ofSeq |\u003E Array.rev\n\n/// Get opening prices for MSFT for the last 100 days\nlet msftOpens: float[] = getStockPrices \u0022MSFT\u0022 100\n\n(**\n## Calling R functions\n\nNow, we\u0027re ready to call R functions using the type provider. The following snippet takes\n\u0060msftOpens\u0060, calculates logarithm of the values using \u0060R.log\u0060 and then calculates the \ndifferences of the resulting vector using \u0060R.diff\u0060:\n*)\n\n// Retrieve stock price time series and compute returns\nlet msft = msftOpens |\u003E R.log |\u003E R.diff\n\n\n(**\nIf you want to see the resulting values, you can call \u0060msft.AsVector()\u0060 in F# Interactive.\nNext, we use the \u0060acf\u0060 function to display the atuo-correlation and call \u0060adf_test\u0060 to\nsee if the \u0060msft\u0060 returns are stationary/non-unit root:\n*)\n\nlet a = R.acf(msft)\nlet adf = R.adf_test(msft) \n\n(**\nAfter running the first snippet, a window similar to the following should appear (note that\nit might not appear as a top-most window).\n\n\u003Cdiv style=\u0022text-align:center\u0022\u003E\n\u003Cimg src=\u0022img/acf.png\u0022 /\u003E\n\u003C/div\u003E\n\nFinally, we can obtain data for multiple different indicators and use the \u0060R.pairs\u0060 function\nto produce a matrix of scatter plots:\n*)\n\n// Build a list of tickers and get diff of logs of prices for each one\nlet tickers = \n  [ \u0022MSFT\u0022; \u0022AAPL\u0022; \u0022X\u0022; \u0022VXX\u0022; \u0022SPX\u0022; \u0022GLD\u0022 ]\nlet data =\n  [ for t in tickers -\u003E \n      printfn \u0022got one!\u0022\n      t, getStockPrices t 255 |\u003E R.log |\u003E R.diff ]\n\n// Create an R data frame with the data and call \u0027R.pairs\u0027\nlet df = R.data_frame(namedParams data)\nR.pairs(df)\n\n(**\nAs a result, you should see a window showing results similar to these:\n\n\u003Cdiv style=\u0022text-align:center\u0022\u003E\n\u003Cimg src=\u0022img/pairs.png\u0022 /\u003E\n\u003C/div\u003E\n\n*)"},{"uri":"https://fslab.org/RProvider/requirements.html","title":"Requirements: Getting Started\n","content":"(**\n---\ncategory: Documentation\ncategoryindex: 1\nindex: 1\n---\n*)\n\n(*** condition: prepare ***)\n#nowarn \u0022211\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.Runtime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.DesignTime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.dll\u0022\n(*** condition: fsx ***)\n#if FSX\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // IPYNB\n\n(** \nRequirements: Getting Started\n=================================\n\nThe R type provider can be used on macOS, Windows, and Linux (for supported OS versions,\nsee the [.NET 5 OS support matrix](https://github.com/dotnet/core/blob/main/release-notes/5.0/5.0-supported-os.md)).\n\nThere are three **requirements** to use the R type provider:\n\n- [dotnet SDK](https://www.microsoft.com/net/download/core) 5.0 or greater; and\n- [R statistical environment](http://cran.r-project.org/).\n- A correctly set \u0060R_HOME\u0060 environment variable (see below).\n  You **must** set the \u0060R_HOME\u0060 environment variable to the R home directory, \n  which can usually be identified by running the command \u0027R RHOME\u0027. \n\nNote. If you require .NET framework / mono support, you should use RProvider 1.2 or earlier.\nSupport for .NET versions below 5.0 was dropped with RProvider 2.0.\n\nSetting the \u0060R_HOME\u0060 environment variable\n----------------------\nThe R type provider requires that the R_HOME environment variable is set, so that\nit can find the R installation that you wish to use. \n\n#### macOS\nIn a Terminal window, execute the following command to add the R_HOME environment\nvariable permanently:\n\n    [lang=bash]\n    echo export R_HOME=$(R RHOME) \u003E\u003E ~/.zshenv\n\n#### Linux\n\nYou can set the R_HOME environment variable in your current session\nusing the command:\n\n    [lang=bash]\n    export R_HOME=$(R RHOME)\n\n#### Windows\n\nOn Windows, from a command prompt use the following command to set\nthe R_HOME permanently as a user environment variable, replacing C:\\rpath\\bin\nwith your R install location:\n\n    [lang=cmd]\n    setx R_HOME \u0022C:\\rpath\\bin\u0022\n\nTesting the R provider\n----------------------\n\nYou can now start experimenting with the R type provider using your favourite editor,\nor directly from the command line using\n\n    [lang=bash]\n    dotnet fsi\n\nThe easiest way to get started is to install Visual Studio Code, making sure to also install\nthe Ionide-fsharp extension within the Extensions tab.\n\nFirst, create a new file with the extension .fsx (e.g., test.fsx). Second, reference the\nR type provider package from NuGet by adding this line to the start of your file:\n\n    [lang=fsharp]\n    #r \u0022nuget: RProvider,2.0.2\u0022\n\nThird, add your code. In this code, we load RProvider, then load three R packages using\nthe \u0060open\u0060 declarations (graphics, grDevices, and datasets).\n*)\n\nopen RProvider\nopen RProvider.graphics\nopen RProvider.grDevices\nopen RProvider.datasets\n(**\nNow we can run some calculations and create charts. When using R on Mac, the default graphics\ndevice (Quartz) sometimes hangs, but X11 is working without issues, so the following uses X11:\n*)\n// basic test if RProvider works correctly\nR.mean([1;2;3;4])\n// val it : RDotNet.SymbolicExpression = [1] 2.5\n\n\n(***do-not-eval***)\n// testing graphics\nR.x11()\n\n(***do-not-eval***)\n// Calculate sin using the R \u0027sin\u0027 function\n// (converting results to \u0027float\u0027) and plot it\n[ for x in 0.0 .. 0.1 .. 3.14 -\u003E \n    R.sin(x).GetValue\u003Cfloat\u003E() ]\n|\u003E R.plot\n\n// Plot the data from the standard \u0027Nile\u0027 data set\nR.plot(R.Nile)\n(**\nDiagnostics and debugging\n-------------------------\n\nIf you encounter any issues, please do not hesitate to submit an issue! You can do that on the\n[GitHub page](https://github.com/fslaborg/RProvider/issues). Before submitting\nan issue, please see the [Diagnostics and debugging page](diagnostics.html), which tells you how\nto create a log file with more detailed information about the issues.\n*)\n\n\n\n\n\n"},{"uri":"https://fslab.org/RProvider/internals.html","title":"How does it work?\n","content":"---\ncategory: Developer\ncategoryindex: 2\nindex: 3\n---\n\n# How does it work?\n\n## How do we call into R?\nThe RProvider loads the R.DLL (which contains the core of R) into the calling process, via [RDotNet](http://rdotnet.codeplex.com/).  This will happen in several places:\n\n* In the IDE, to provide IntelliSense for packages/functions/parameters.\n* In the F# compiler, to generate code that calls the R functionality you are calling.\n* In your resulting binary, to execute the generated code.\n* In F# Interactive, to do all of the above interactively.\n\n## How does RDotNet help?\nRDotNet allows R functionality to be called from .NET, and exposes an object model for representing R values (based on the type RDotNet.SymbolExpression).  Using RDotNet, one executes R code by passing strings of R code into an Evaluate method.  From the RProvider, we introspect on available R packages and functions and expose them as members of provided types.  You can then call them just like regular .NET functions, with IntelliSense and compile-time checking.  RDotNet.SymbolicExpression provides a nice OO model of the R native SEXP type, so we simply expose results using that type.  To make it more friendly from F#, we extend it with some extension members and active patterns.\n\n## How do we expose R packages?\nRProvider determines the set of installed packages in your R installation and exposes them as namespaces under the root RProvider namespace.  This allows you to \u0027open\u0027 the namespaces you want to use as if they were regular .NET namespaces.\n\nUnder the namespace for a given package, RProvider exposes a single static type called \u0022R\u0022, which contains static methods mirroring each of the functions and values that exist in the package.  This means that the members under \u0022R.\u0022 will be the union of available functions in all of the package namespaces you have opened.\n\n## Is it Statically Typed?\nKind of.  It is statically type checked to the extent that it can be given the type information available from R.  In practice, this means that the F# compiler and IDE statically checks that the function you are calling exists in the package you are calling.  In some cases, we can also determine that you are not passing too many arguments to the function, though common use of ... (aka varargs/params) in R functions defeats that in many cases.\n\nR is dynamically typed, so we cannot determine what the types of function arguments are supposed to be.  So all arguments are of type obj.  R functions can also be written such that they will work even if arguments that do not have default values are omitted, so we expose each argument as optional.  And for R functions that accept a ... argument, we expose a paramarray argument that allows any number of additional arguments to be passed.  In that case, you can basically pass any number of arguments to the function."},{"uri":"https://fslab.org/RProvider/expressions.html","title":"Working with R expressions\n","content":"(** \n---\ncategory: Documentation\ncategoryindex: 1\nindex: 4\n---\n*)\n\n(*** condition: prepare ***)\n#nowarn \u0022211\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/DynamicInterop.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.FSharp.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.Runtime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.DesignTime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.dll\u0022\n(*** condition: fsx ***)\n#if FSX\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // IPYNB\n\n(**\nWorking with R expressions\n===============\n\nRProvider represents R objects and values through a \u0060SymbolicExpression\u0060 type (derived from R.NET). RProvider includes a \u0060SymbolicExpression\u0060 module that allows you to work with R expressions in a more idiomatic way using forward pipes (\u0060|\u003E\u0060). First, open RProvider, its custom operators and any packages you need:\n*)\n\nopen RProvider\nopen RProvider.Operators\n\nopen RProvider.\u0060\u0060base\u0060\u0060\nopen RProvider.datasets\nopen RProvider.stats\n\n(**\n\n# S4 classes\n\nFor this example, let\u0027s set up an S4 class and object from scratch:\n*)\n\nlet x = R.rnorm(100)\nx.Engine.Evaluate(\u0022setClass(\u0027testclass\u0027, representation(foo=\u0027character\u0027, bar=\u0027integer\u0027))\u0022)\nlet s4 = x.Engine.Evaluate(\u0022new(\u0027testclass\u0027, foo=\u0027s4\u0027, bar=1:4)\u0022)\n\n(**\nYou can find out if there are slots using the \u0060slots\u0060 and \u0060trySlots\u0060 functions:\n*)\n\ns4 |\u003E SymbolicExpression.slots\ns4 |\u003E SymbolicExpression.trySlots\nR.mtcars |\u003E SymbolicExpression.trySlots\n\n(**\nYou can access slot values similarly with the \u0060slot\u0060 and \u0060trySlot\u0060 functions:\n*)\n\ns4 |\u003E SymbolicExpression.slot \u0022foo\u0022\ns4 |\u003E SymbolicExpression.trySlot \u0022foo\u0022\ns4 |\u003E SymbolicExpression.trySlot \u0022doesntexist\u0022"},{"uri":"https://fslab.org/RProvider/index.html","title":"F# R Type Provider\n","content":"F# R Type Provider\n=======\n\n\nThe F# Type Provider is a mechanism that enables smooth interoperability\nbetween F# and [R](http://www.r-project.org/). \nThe Type Provider discovers R packages that are available \nin your R installation and makes them available as .NET namespaces \nunderneath the parent namespace \u0060RProvider\u0060. \n\nThe Type Provider makes it possible to use \nall of R capabilities, from the F# interactive environment. \nIt enables on-the-fly charting and data analysis using R packages, \nwith the added benefit of IntelliSense over R, \nand compile-time type-checking that the R functions you are using exist. \nIt allows you to leverage all of .NET libraries,\nas well as F# unique capabilities to access and manipulate data \nfrom a wide variety of sources via Type Providers.\n\n![RProvider demo within an FSharp script](img/vscode.gif)\n\nThe above example is run through F# interactive (\u0060dotnet fsi\u0060).\n\n### A Quick Demo\n\n\u003Cdiv style=\u0022text-align:center;\u0022\u003E\n\u003Ciframe width=\u0022420\u0022 height=\u0022315\u0022 src=\u0022https://www.youtube.com/embed/tOd-qsjKU8Y\u0022 frameborder=\u00220\u0022 allowfullscreen\u003E\u003C/iframe\u003E\n\u003C/div\u003E\n\n## What are R and F#?\n\n[F#](http://fsharp.org) is a multi-paradigm language \nthat supports functional, object and imperative programming, \nwith the emphasis on functional-first programming. F# runs on the .NET runtime and is a compiled, \nstatically typed language with a strong type system and type inference. \nF# is a general purpose programming language, and is particularly well-suited for scientific/numerical computing.\n\n[R](http://www.r-project.org/) is an Open Source language for statistical computing. \nR offers a wide range of high-quality, community-developed packages, \ncovering virtually every area of statistics, econometrics or machine learning. \nIt is also famous for its charting capabilities, making it a great tool \nto produce publication-quality graphics. \nR is an interpreted, dynamically typed language that is typically used \nfrom its GUI, [RStudio](http://www.rstudio.com/), or command line interactive environment.\n\n## Using the R Type Provider\n\nRProvider is distributed as a nuget package. After [setting up the pre-requisites (installing .NET 5\u002B, R and setting the R_HOME environment variable](requirements.html), you can use as follows:\n\nIn an F# script:\n\u0060\u0060\u0060fsharp\n#r \u0022nuget:RProvider\u0022\n\nopen RProvider\n\u0060\u0060\u0060\n\nTo add to a .NET project, from the terminal:\n\u0060\u0060\u0060\ndotnet add package RProvider\n\u0060\u0060\u0060\n\nContributing and copyright\n--------------------------\n\nThe project has been originally developed by [BlueMountain Capital](https://www.bluemountaincapital.com/) and contributors.\n\nFor compilation of the source, you will need F# 5.0 or later.  For runtime you\u0027ll need .NET 5.\n\nThe project is hosted on [GitHub][gh] where you can [report issues][issues], fork the project and submit pull requests.\n\n[gh]: https://github.com/fslaborg/RProvider\n[issues]: https://github.com/fslaborg/RProvider/issues\n[license]: https://github.com/fslaborg/RProvider/blob/master/LICENSE.md\n"},{"uri":"https://fslab.org/RProvider/operators.html","title":"Operators\n","content":"(** \n---\ncategory: Documentation\ncategoryindex: 1\nindex: 4\n---\n*)\n\n(*** condition: prepare ***)\n#nowarn \u0022211\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/DynamicInterop.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.FSharp.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.Runtime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.DesignTime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.dll\u0022\n(*** condition: fsx ***)\n#if FSX\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // IPYNB\n\n(**\nOperators\n===============\n\nRProvider includes the \u0060RProvider.Operators\u0060 module, which contains custom operators that can make working with R easier. Make sure to open it alongside your packages:\n*)\n\nopen RProvider\nopen RProvider.Operators\n\nopen RProvider.\u0060\u0060base\u0060\u0060\nopen RProvider.datasets\nopen RProvider.stats\n\n(**\n# Accessing members / slots\n\nYou can use the dynamic (\u0060?\u0060) operator to access:\n\n* Slots in S4 objects\n* Members of list types\n\n### List: accessing named columns in a dataframe.\n\n*)\n\nR.mtcars?mpg\n\n(**\n###\u00A0S4 object: access a slot \n*)\n\nlet x = R.rnorm(100)\nx.Engine.Evaluate(\u0022setClass(\u0027testclass\u0027, representation(foo=\u0027character\u0027, bar=\u0027integer\u0027))\u0022)\n\nlet test = x.Engine.Evaluate(\u0022new(\u0027testclass\u0027, foo=\u0027s4\u0027, bar=1:4)\u0022)\n\ntest?foo"},{"uri":"https://fslab.org/RProvider/plugins.html","title":"Plugins\n","content":"---\ncategory: Developer\ncategoryindex: 2\nindex: 3\n---\n\n# Plugins\n\nRProvider supports plugins to support custom functionality.  It uses [MEF](http://msdn.microsoft.com/en-us/library/dd460648.aspx) to load plugins that export certain contracts.  See below for examples.\n\nBefore implementing a plugin you should consider whether your conversion is universally applicable and should be added to the core conversion logic in the provider.  If so, please log as an issue, and ideally fork the repo and submit a pull request.\n\n## Supporting an implicit parameter conversion for a datatype \n\n## Supporting an explicit result conversion for a datatype\n\n## Supporting a default result conversion"},{"uri":"https://fslab.org/RProvider/quickstart-charts.html","title":"Quickstart: Creating Charts\n","content":"(**\n---\ncategory: Documentation\ncategoryindex: 1\nindex: 3\n---\n*)\n\n(*** condition: prepare ***)\n#nowarn \u0022211\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/DynamicInterop.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.Runtime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.DesignTime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.dll\u0022\n(*** condition: fsx ***)\n#if FSX\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // IPYNB\n\n(** \n# Quickstart: Creating Charts\n\nOne of the compelling features of R is its ability to create beautiful charts.\nWith the R Type Provider, you can use all of R capabilities from F#, \nand create simple charts quickly to explore and visualize your data on-the-fly, \nas well as generate publication quality graphics that can be exported to virtually any format.\n\n## Charts Basics\n\nBasic charts can be found in the graphics package.\nAssuming you are using an F# script, \nyou can reference the required libraries and packages this way:\n\n    [lang=fsharp]\n    #r \u0022nuget: RProvider,2.0.2\u0022\n*)\n\nopen RProvider\nopen RProvider.Operators\nopen RProvider.graphics\n\n(**\nOnce the libraries and packages have been loaded, \nproducing basic charts is as simple as this:\n*)\n\nlet widgets = [ 3; 8; 12; 15; 19; 18; 18; 20; ]\nlet sprockets = [ 5; 4; 6; 7; 12; 9; 5; 6; ]\n\n(***do-not-eval***)\nR.plot(widgets)\n\nR.plot(widgets, sprockets)\n\nR.barplot(widgets)\n\nR.hist(sprockets)\n\nR.pie(widgets)\n\n(**\n## Exporting and Saving Charts\n\nCharts can be exported and saved to various formats; \nonce you have opened the grDevices package, you can save a chart like this:\n*)\n\n(***do-not-eval***)\n// Required package to save charts\nopen RProvider.grDevices\n\n// Create path to an image testimage.png on the Desktop\nlet desktop = System.Environment.GetFolderPath(System.Environment.SpecialFolder.Desktop)  \nlet path = desktop \u002B @\u0022\\testimage.png\u0022\n\n// Open the device and create the file as a png.\n// R.bmp, R.jpeg, R.pdf, ... will generate other formats.\nR.png(filename=path, height=200, width=300, bg=\u0022white\u0022)\n// Create the chart into the file\nR.barplot(widgets)\n// Close the device once the chart is complete\nR.dev_off ()\n\n\n(**\n## Advanced Charts Options\n\nThe graphic functions exposed by the R Type Provider come in two flavors; \nthey either have optional named arguments, \nfollowed by a ParamArray for extended arguments, \nor they take named parameters, an IDictionary\u003Cstring,object\u003E \nwhich contains all the arguments passed to the function.\n\n### Named Arguments\n\nConsider for instance the following example:\n*)\n\n(***do-not-eval***)\nR.barplot(widgets)\nR.title(main=\u0022Widgets\u0022, xlab=\u0022Period\u0022, ylab=\u0022Quantity\u0022)\n\n(**\nR.title has 2 signatures, one of them with optional arguments, \ndemonstrated above to set the main title as well as the labels for the x and y axis, \nignoring some of the other available options. \nYou can see another example in the previous section in the R.png call.\n\n### Named Parameters\n\nNamed parameters allow you to specify every argument supported by R, \nas an IDictionary of string, object. \nThe string is the name of the argument, and the object its value.\n\nFinding the available arguments for a R function can be tricky;\nthe full list of arguments can usually be found in the \n[R developer documentation](http://stat.ethz.ch/R-manual/R-devel/library/),\nnavigating in the correct package. For instance, R.plot belongs to\ngraphics, and can be found \n[here](http://stat.ethz.ch/R-manual/R-devel/library/graphics/html/plot.html).\n\nThe easiest way to use that feature is to \nleverage the built-in function namedParams, like in this example:\n*)\n\n(***do-not-eval***)\nR.plot([\n    \u0022x\u0022 =\u003E widgets\n    \u0022type\u0022 =\u003E \u0022o\u0022\n    \u0022col\u0022 =\u003E \u0022blue\u0022\n    \u0022ylim\u0022 =\u003E [0; 25] ])\n\nR.lines([\n    \u0022x\u0022 =\u003E sprockets\n    \u0022type\u0022 =\u003E \u0022o\u0022\n    \u0022pch\u0022 =\u003E 22\n    \u0022lty\u0022 =\u003E 2\n    \u0022col\u0022 =\u003E \u0022red\u0022 ])\n\n(**\nThe first call specifies what to plot (widgets), \nwhat type of line to use, the color, and the scale of the axis. \nThe second call adds sprockets, specifying lty (the line type), \nand pch (the plotting character).\n\nbox is used to reduce all elements to objects, \nso that the lists have consistent types.\n\nA possibly more elegant way to use namedParams is to follow the pattern below:\n*)\n\n(***do-not-eval***)\n[   \n    \u0022x\u0022 =\u003E widgets\n    \u0022type\u0022 =\u003E \u0022o\u0022\n    \u0022col\u0022 =\u003E \u0022blue\u0022\n    \u0022ylim\u0022 =\u003E [0; 25] ]\n|\u003E R.plot\n\n[   \n    \u0022x\u0022 =\u003E sprockets\n    \u0022type\u0022 =\u003E \u0022o\u0022\n    \u0022pch\u0022 =\u003E 22\n    \u0022lty\u0022 =\u003E 2\n    \u0022col\u0022 =\u003E \u0022red\u0022 ]\n|\u003E R.lines"},{"uri":"https://fslab.org/RProvider/fslab.html","title":"Working with the FsLab ecosystem\n","content":"(**\n---\ncategory: Documentation\ncategoryindex: 1\nindex: 6\n---\n*)\n\n(*** condition: prepare ***)\n#nowarn \u0022211\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RDotNet.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.Runtime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.DesignTime.dll\u0022\n#r \u0022../src/RProvider/bin/Release/net5.0/RProvider.dll\u0022\n(*** condition: fsx ***)\n#if FSX\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \u0022nuget: RProvider,{{package-version}}\u0022\n#endif // IPYNB\n\n(**\nWorking with the FsLab ecosystem\n===============================\n\nThe R type provider is interoperable with other packages in\nFsLab through its plugin architecture. Some examples are shown\nbelow. If you would like to see better interoperability between\nR and other FsLab packages, submit an issue to their repository\nfor the creation of an RProvider plugin.\n\n### Deedle - data frame manipulation\n\nDeedle provides types for F# data frame and time series manipulation.\nTo use with RProvider, first install the Deedle.RPlugin package from\nnuget; once this is installed, you do not need to reference it in your\nscript files.\n*)\n\n#r \u0022nuget:Deedle.RPlugin\u0022\n\n(**\nIn a new F# script file, first open Deedle and RProvider: \n\n    [lang=fsharp]\n    #r \u0022nuget:RProvider\u0022\n*)\n\n#r \u0022nuget:Deedle\u0022\n\nopen RProvider\nopen RProvider.\u0060\u0060base\u0060\u0060\nopen RProvider.datasets\nopen Deedle\n\n(**\nThe Deedle R plugin should be loaded by the R type provider automatically.\nYou can now convert back and forth between R data frames and Deedle frames\nby using type annotations:\n*)\n\nlet mtcars : Frame\u003Cstring, string\u003E = R.mtcars.GetValue()\n\n// Pass Deedle data to R and print the R output\nR.as_data_frame(mtcars)\n\n// Pass Deedle data to R and get column means\nR.colMeans(mtcars)"},{"uri":"https://fslab.org/RProvider/whatwhy.html","title":"Whats and Whys\n","content":"---\ncategory: Documentation\ncategoryindex: 1\nindex: 3\n---\n\n# Whats and Whys\n\n## What is R?\n\n[R](http://www.r-project.org/) is an Open Source package for statistical computing.  There are a wide range of community-developed packages available that are very useful in the statistical computing/econometrics space.\n\nR is an interpreted, dynamically typed language that is typically used from its GUI or command line interactive environment.  But R is also embeddable using the R.DLL.\n\n## What is F#?\n\n[F#](http://msdn.microsoft.com/en-us/vstudio/hh388569) is a mixed-paradigm language that supports functional, object-oriented and imperative programming, with the emphasis on functional.  F# runs on the .NET runtime and is a compiled, statically typed language with a strong type system and type inference.  F# is typically used in the scientific/numerical computing space, though is quite widely applicable.\n\n## Why use R with F#?\n\nWhile there are a number of math/statistical packages available for the .NET platform, none of the approach the power of the packages that are available for R.  R also includes versatile packages for visualization which are hard to match on .NET.\n\n## What is a Type Provider?\n\nF# 3.0 supports a new feature called [Type Providers](http://msdn.microsoft.com/en-us/library/hh156509.aspx) which allow a set of types and members to be determined at compile time (or in the IDE) based on statically known parameters and (optionally) access to some external resource.  The primary purpose of Type Providers is to support strongly-typed access to external data sources, without the additional step of code generation, which adds friction to the development process and is sometimes impractical due to the size of the type space.  Type Providers can also be used to interoperate with another language or runtime environment, by introspecting on constructs available in that environment during compile time and making equivalent constructs available to F#.\n\n## Why not just use R directly?\n\nIn some cases, this will make a lot of sense, but there are a number of reasons why it might not:\n\n1. F# is particularly well-suited for the retrieval and manipulation/cleansing of data, which we will subsequently want to use in statistical models.\n2. We can combine functionality in .NET libraries (or otherwise callable from F#) with R functionality in a low-friction way.\n3. F# is well-suited to building scalable production applications, and using the R type provider allows us to use R functionality from those applications?\n"},{"uri":"https://fslab.org/RProvider/diagnostics.html","title":"Diagnostics and debugging\n","content":"---\ncategory: Developer\ncategoryindex: 2\nindex: 3\n---\n\nDiagnostics and debugging\n=========================\n\nThe R type provider has an extensive logging to help developers diagnose\npotential issues. If you encounter any issues with the R type provider, this\npage gives you all the information you need to create a log file with detailed\ntrace of what is going one. This may give you some hints on what is wrong \u0026 a\ndetailed report that you can send when [submitting an\nissue](https://github.com/fslaborg/RProvider/issues).\n\n**TL;DR** The logging is enabled by setting an environment variable\n\u0060RPROVIDER_LOG\u0060 to a file name where the log should be saved. The file does\nnot have to exist, but the folder where it is located has to. **You should use\nan absolute (full) path, as otherwise the server will create a seperate log in the\nnuget package directory.**\n\nEnabling logging on Windows\n---------------------------\n\nOn Windows, you can set environment variables by going to system properties\n(this varies depending on the OS version, but generally right click on\n\u0022My Computer\u0022 and select a link or button saying something like \u0022Change settings\u0022).\n\nThis should open a new dialog, where you can go to \u0022Advanced\u0022, and click on the\n\u0022Environment Variables\u0022 button. Here, you can add the variable as either per-user\nor per-system and save it. For example, create a folder \u0060C:\\Temp\u0060 and set\n\u0060RPROVIDER_LOG\u0060 to \u0060C:\\Temp\\rlog.txt\u0060. After you restart Visual Studio, the\nR provider will start logging.\n\nEnabling logging on Mac/Linux\n-----------------------------\n\nIf you\u0027re using Xamarin Studio on Mac, then the easiest option is to set the\nvariable from Terminal and then start Xamarin Studio from terminal. Note that\nif you set the environment variable from terminal, but launch Xamarin Studio\nfrom Dock or in some other way, it will not see the variable!\n\nThe following should do the trick (assuming the folder \u0060/Users/tomasp/Temp\u0060 exists):\n\n    [lang=text]\n    export RPROVIDER_LOG=/Users/tomasp/Temp/rlog.txt\n    open -n /Applications/Xamarin\\ Studio.app/\n\nThis will set the variable and start a new instance of Xamarin Studio in the current\ncontext. Once it appears, reporduce the operation that causes the error, close\nXamarin Studio and look at the log file.\n\nEnabling logging in a custom build\n----------------------------------\n\nIf you\u0027re building R provider from source, you can also enable logging by changing\nthe \u0060loggingEnabled\u0060 constant in the source code (and change \u0060logFile\u0060 if you want\nto override the default location). See the [right place for this on\nGitHub](https://github.com/fslaborg/RProvider/blob/master/src/RProvider/Logging.fs#L13).\n"}]